#!/usr/bin/env bash
# This script was generated by bashly 1.0.5 (https://bashly.dannyb.co)
# Modifying it manually is not recommended

# :wrapper.bash3_bouncer
if [[ "${BASH_VERSINFO:-0}" -lt 4 ]]; then
  printf "bash version 4 or higher is required\n" >&2
  exit 1
fi

# :command.master_script

# :command.version_command
version_command() {
  echo "$version"
}

# :command.usage
shisper_usage() {
  if [[ -n $long_usage ]]; then
    printf "shisper - A quick & dirty script to generate subs and transcriptions for your multimedia files.\n"
    echo

  else
    printf "shisper - A quick & dirty script to generate subs and transcriptions for your multimedia files.\n"
    echo

  fi

  printf "%s\n" "Usage:"
  printf "  shisper COMMAND\n"
  printf "  shisper [COMMAND] --help | -h\n"
  printf "  shisper --version | -v\n"
  echo
  # :command.usage_commands
  printf "%s\n" "Commands:"
  printf "  %s   Play a media file with generated subtitles / transcriptions\n" "play       "
  printf "  %s   Generate subtitles / transcriptions using your audio inputs\n" "stream     "
  printf "  %s   Generate subtitles / transcriptions for any kind of media file\n" "transcribe "
  printf "  %s   Show the entire config file\n" "list       "
  printf "  %s   Generate bash completions\n" "completions"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo
    printf "  %s\n" "--version, -v"
    printf "    Show version number\n"
    echo

    # :command.usage_environment_variables
    printf "%s\n" "Environment Variables:"

    # :environment_variable.usage
    printf "  %s\n" "MODEL_PATH (required)"
    printf "    Set the model home path\n"
    printf "    Default: ${HOME}/.local/share/whispercpp\n"
    echo

  fi
}

# :command.usage
shisper_play_usage() {
  if [[ -n $long_usage ]]; then
    printf "shisper play - Play a media file with generated subtitles / transcriptions\n"
    echo

  else
    printf "shisper play - Play a media file with generated subtitles / transcriptions\n"
    echo

  fi

  printf "%s\n" "Usage:"
  printf "  shisper play MEDIA_FILE [SUB_FORMAT]\n"
  printf "  shisper play --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "MEDIA_FILE"
    printf "    Video or audio file\n"
    echo

    # :argument.usage
    printf "  %s\n" "SUB_FORMAT"
    printf "    Format for subtitles / transcription\n    Supported values\n    txt vtt srt lrc words csv json\n"
    printf "    Default: srt\n"
    echo

  fi
}

# :command.usage
shisper_stream_usage() {
  if [[ -n $long_usage ]]; then
    printf "shisper stream - Generate subtitles / transcriptions using your audio inputs\n"
    echo

  else
    printf "shisper stream - Generate subtitles / transcriptions using your audio inputs\n"
    echo

  fi

  printf "%s\n" "Usage:"
  printf "  shisper stream\n"
  printf "  shisper stream --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
shisper_transcribe_usage() {
  if [[ -n $long_usage ]]; then
    printf "shisper transcribe - Generate subtitles / transcriptions for any kind of media file\n"
    echo

  else
    printf "shisper transcribe - Generate subtitles / transcriptions for any kind of media file\n"
    echo

  fi

  printf "%s\n" "Usage:"
  printf "  shisper transcribe MEDIA_FILE [SUB_FORMAT]\n"
  printf "  shisper transcribe --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "MEDIA_FILE"
    printf "    Video or audio file\n"
    echo

    # :argument.usage
    printf "  %s\n" "SUB_FORMAT"
    printf "    Format for subtitles / transcription\n    Supported values\n    txt vtt srt lrc words csv json\n"
    printf "    Default: srt\n"
    echo

    # :command.usage_examples
    printf "%s\n" "Examples:"
    printf "  shisper transcribe my_video.mkv\n"
    printf "  shisper transcribe my_audio.mp3\n"
    echo

  fi
}

# :command.usage
shisper_list_usage() {
  if [[ -n $long_usage ]]; then
    printf "shisper list - Show the entire config file\n"
    echo

  else
    printf "shisper list - Show the entire config file\n"
    echo

  fi

  printf "Alias: l\n"
  echo

  printf "%s\n" "Usage:"
  printf "  shisper list\n"
  printf "  shisper list --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
shisper_completions_usage() {
  if [[ -n $long_usage ]]; then
    printf "shisper completions\n"
    echo

    printf "  Generate bash completions\n  Usage: eval \"\$(shisper completions)\"\n"
    echo

  else
    printf "shisper completions - Generate bash completions\n"
    echo

  fi

  printf "%s\n" "Usage:"
  printf "  shisper completions\n"
  printf "  shisper completions --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_examples
    printf "%s\n" "Examples:"
    printf "  shisper play my_video.mkv\n"
    printf "  shisper play my_audio.mp3\n"
    echo

  fi
}

# :command.normalize_input
normalize_input() {
  local arg flags

  while [[ $# -gt 0 ]]; do
    arg="$1"
    if [[ $arg =~ ^(--[a-zA-Z0-9_\-]+)=(.+)$ ]]; then
      input+=("${BASH_REMATCH[1]}")
      input+=("${BASH_REMATCH[2]}")
    elif [[ $arg =~ ^(-[a-zA-Z0-9])=(.+)$ ]]; then
      input+=("${BASH_REMATCH[1]}")
      input+=("${BASH_REMATCH[2]}")
    elif [[ $arg =~ ^-([a-zA-Z0-9][a-zA-Z0-9]+)$ ]]; then
      flags="${BASH_REMATCH[1]}"
      for ((i = 0; i < ${#flags}; i++)); do
        input+=("-${flags:i:1}")
      done
    else
      input+=("$arg")
    fi

    shift
  done
}
# :command.inspect_args
inspect_args() {
  if ((${#args[@]})); then
    readarray -t sorted_keys < <(printf '%s\n' "${!args[@]}" | sort)
    echo args:
    for k in "${sorted_keys[@]}"; do echo "- \${args[$k]} = ${args[$k]}"; done
  else
    echo args: none
  fi

  if ((${#other_args[@]})); then
    echo
    echo other_args:
    echo "- \${other_args[*]} = ${other_args[*]}"
    for i in "${!other_args[@]}"; do
      echo "- \${other_args[$i]} = ${other_args[$i]}"
    done
  fi

  if ((${#deps[@]})); then
    readarray -t sorted_keys < <(printf '%s\n' "${!deps[@]}" | sort)
    echo
    echo deps:
    for k in "${sorted_keys[@]}"; do echo "- \${deps[$k]} = ${deps[$k]}"; done
  fi

}

# :command.user_lib
# src/lib/colors.sh
print_in_color() {
  local color="$1"
  shift
  if [[ -z ${NO_COLOR+x} ]]; then
    printf "$color%b\e[0m\n" "$*"
  else
    printf "%b\n" "$*"
  fi
}

red() { print_in_color "\e[31m" "$*"; }
green() { print_in_color "\e[32m" "$*"; }
yellow() { print_in_color "\e[33m" "$*"; }
blue() { print_in_color "\e[34m" "$*"; }
magenta() { print_in_color "\e[35m" "$*"; }
cyan() { print_in_color "\e[36m" "$*"; }
bold() { print_in_color "\e[1m" "$*"; }
underlined() { print_in_color "\e[4m" "$*"; }
red_bold() { print_in_color "\e[1;31m" "$*"; }
green_bold() { print_in_color "\e[1;32m" "$*"; }
yellow_bold() { print_in_color "\e[1;33m" "$*"; }
blue_bold() { print_in_color "\e[1;34m" "$*"; }
magenta_bold() { print_in_color "\e[1;35m" "$*"; }
cyan_bold() { print_in_color "\e[1;36m" "$*"; }
red_underlined() { print_in_color "\e[4;31m" "$*"; }
green_underlined() { print_in_color "\e[4;32m" "$*"; }
yellow_underlined() { print_in_color "\e[4;33m" "$*"; }
blue_underlined() { print_in_color "\e[4;34m" "$*"; }
magenta_underlined() { print_in_color "\e[4;35m" "$*"; }
cyan_underlined() { print_in_color "\e[4;36m" "$*"; }

# src/lib/config.sh
config_init() {
  if [[ ! -f "/etc/shisper/config.ini" ]]; then
    CONFIG_FILE=${CONFIG_FILE:=${HOME}/.shisperrc}
    [[ -f "$CONFIG_FILE" ]] || touch "$CONFIG_FILE"
  else
    CONFIG_FILE="/etc/shisper/config.ini"
  fi
}

config_get() {
  local key=$1
  local regex="^$key *= *(.+)$"
  local value=""

  config_init

  while IFS= read -r line || [ -n "$line" ]; do
    if [[ $line =~ $regex ]]; then
      value="${BASH_REMATCH[1]}"
      break
    fi
  done <"$CONFIG_FILE"

  echo "$value"
}

config_set() {
  local key=$1
  shift
  local value="$*"

  config_init

  local regex="^($key) *= *.+$"
  local output=""
  local found_key=""
  local newline

  while IFS= read -r line || [ -n "$line" ]; do
    newline=$line
    if [[ $line =~ $regex ]]; then
      found_key="${BASH_REMATCH[1]}"
      newline="$key = $value"
      output="$output$newline\n"
    elif [[ $line ]]; then
      output="$output$line\n"
    fi
  done <"$CONFIG_FILE"

  if [[ -z $found_key ]]; then
    output="$output$key = $value\n"
  fi

  printf "%b\n" "$output" >"$CONFIG_FILE"
}

config_del() {
  local key=$1

  local regex="^($key) *="
  local output=""

  config_init

  while IFS= read -r line || [ -n "$line" ]; do
    if [[ $line ]] && [[ ! $line =~ $regex ]]; then
      output="$output$line\n"
    fi
  done <"$CONFIG_FILE"

  printf "%b\n" "$output" >"$CONFIG_FILE"
}

config_show() {
  config_init
  cat "$CONFIG_FILE"
}

config_keys() {
  local regex="^([a-zA-Z0-9_\-\/\.]+) *="

  config_init

  local keys=()
  local key

  while IFS= read -r line || [ -n "$line" ]; do
    if [[ $line =~ $regex ]]; then
      key="${BASH_REMATCH[1]}"
      keys+=("$key")
    fi
  done <"$CONFIG_FILE"
  echo "${keys[@]}"
}

config_has_key() {
  [[ $(config_get "$1") ]]
}

# src/lib/media.sh
#!/usr/bin/env bash

check_media_type() {
  local media_file="$1"

  mime_type=$(file -i "${media_file}" | cut -d":" -f 2)
  mime_type_stripped="${mime_type//[[:blank:]]/}"
  media_type="${mime_type_stripped//;*/}"

  case "${media_type}" in
  audio*) ;;
  video*) ;;
  *)
    echo -e "[$(red_bold "FAILED")] File type not supported : ${media_type}"
    exit 1
    ;;
  esac

  echo -e "[$(green_bold "  OK  ")] File media type detected: ${media_type}"

}

extract_audio() {
  local media_file="$1"

  echo -e "[$(cyan_bold " INFO ")] Extracting main track as 16Khz wav from ..."
  echo -e "${media_file}"

  ffmpeg -y \
    -loglevel quiet \
    -i "${media_file}" \
    -acodec pcm_s16le -ac 1 -ar 16000 \
    -f wav \
    "${media_file%%.*}"

  echo -e "[$(green_bold "  OK  ")] Audio extraction completed. File is:"
  echo -e "${media_file%%.*}"

}

play_media() {
  local media_file="$1"
  local sub_format="$2"

  echo -e "[$(cyan_bold " INFO ")] Playing file with generated transcription ..."
  echo -e "${media_file}"

  mpv \
    --quiet \
    --sub-file="${media_file%%.*}.${sub_format}" \
    "${media_file}" 1>/dev/null

  echo -e "[$(green_bold "  OK  ")] Playback completed."
}

# src/lib/utils.sh
#!/usr/bin/env bash

clean_temp_file() {
  local media_file="$1"

  echo -e "[$(cyan_bold " INFO ")] Deleting temporary wav files"
  rm "${media_file%%.*}"
}

check_media() {
  local media_file="$1"

  if [[ ! -f "${media_file}" ]]; then
    echo -e "[$(red_bold " FAILED ")] File not found"
    exit 1
  fi
}

check_models() {
  local model_file="$1"

  if [[ ! -d "${MODEL_PATH}" ]]; then
    mkdir -p "${MODEL_PATH}"
  fi

  if [[ -f "${MODEL_PATH}/${model_file}" ]]; then
    echo -e "[$(yellow_bold " WARN ")] ${MODEL_PATH}/${model_file} is present"
  else
    download_model "${model_file}"
  fi
}

check_sub() {
  local media_file="$1"
  local sub_format="$2"

  if [[ ! -f "${media_file%%.*}.${sub_format}" ]]; then
    echo -e "[$(red_bold " FAILED ")] Generated transcription not found"
    exit 1
  fi
}

# src/lib/whisper.sh
#!/usr/bin/env bash
download_model() {
  local model_file="$1"

  echo -e "[$(cyan_bold " INFO ")] Downloading latest ${model_file} ..."
  curl -# -L -C - "https://huggingface.co/datasets/ggerganov/whisper.cpp/resolve/main/${model_file}" \
    -o "${MODEL_PATH}/${model_file}"
}

run_whisper() {
  local media_file="$1"
  local model_file="$2"
  local lang="$3"
  local sub_format="$4"

  whisper.cpp \
    --file "${media_file%%.*}" \
    --language "${lang}" \
    --model "${MODEL_PATH}/${model_file}" \
    --output-"${sub_format}" \
    --no-timestamps >/dev/null

  echo -e "[$(green_bold "  OK  ")] Completed"
  echo -e "[$(cyan_bold " INFO ")] Generated transcription is:"
  echo -e "${media_file%%.*}.${sub_format}"
}

run_whisper_stream() {
  local model_file="$1"
  local lang="$2"

  if [[ "${lang}" == "auto" ]]; then
    lang="en"
  fi

  whisper.cpp-stream \
    --language "${lang}" \
    --model "${MODEL_PATH}/${model_file}"

  echo -e "[$(green_bold "  OK  ")] Completed"
}

# :command.command_functions
# :command.function
shisper_play_command() {
  # src/play_command.sh
  #!/usr/bin/env bash

  media_file="${args[media_file]}"
  sub_format="${args[sub_format]}"

  check_media "${media_file}"
  check_sub "${media_file}" "${sub_format}"
  play_media "${media_file}" "${sub_format}"
}

# :command.function
shisper_stream_command() {
  # src/stream_command.sh
  #!/usr/bin/env bash

  model_file="ggml-$(config_get model).bin"
  lang="$(config_get lang)"

  check_models "${model_file}"
  run_whisper_stream "${model_file}" "${lang}"

}

# :command.function
shisper_transcribe_command() {
  # src/transcribe_command.sh
  #!/usr/bin/env bash

  lang="$(config_get lang)"
  media_file="${args[media_file]}"
  model_file="ggml-$(config_get model).bin"
  # sub_format="$(config_get sub_format)"
  sub_format="${args[sub_format]}"

  check_media "${media_file}"
  check_media_type "${media_file}"
  extract_audio "${media_file}"
  check_models "${model_file}"
  run_whisper "${media_file}" "${model_file}" "${lang}" "${sub_format}"
  clean_temp_file "${media_file}"

}

# :command.function
shisper_list_command() {
  # src/list_command.sh
  #!/usr/bin/env bash

  # Using the standard library (lib/config.sh) to show the entire config file
  config_show

  # Or to iterate through keys
  for key in $(config_keys); do
    echo "$key === $(config_get "${key}")"
  done

}

# :command.function
shisper_completions_command() {
  # src/completions_command.sh
  echo "# this file is located in 'src/completions_command.sh'"
  echo "# code for 'shisper completions' goes here"
  echo "# you can edit it freely and regenerate (it will not be overwritten)"
  inspect_args

}

# :command.parse_requirements
parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --version | -v)
        version_command
        exit
        ;;

      --help | -h)
        long_usage=yes
        shisper_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.environment_variables_filter
  # :command.environment_variables_default
  export MODEL_PATH="${MODEL_PATH:-${HOME}/.local/share/whispercpp}"

  if [[ -z "${MODEL_PATH:-}" ]]; then
    printf "missing required environment variable: MODEL_PATH\n" >&2
    exit 1
  fi

  # :command.command_filter
  action=${1:-}

  case $action in
    -*) ;;

    play)
      action="play"
      shift
      shisper_play_parse_requirements "$@"
      shift $#
      ;;

    stream)
      action="stream"
      shift
      shisper_stream_parse_requirements "$@"
      shift $#
      ;;

    transcribe)
      action="transcribe"
      shift
      shisper_transcribe_parse_requirements "$@"
      shift $#
      ;;

    list | l)
      action="list"
      shift
      shisper_list_parse_requirements "$@"
      shift $#
      ;;

    completions)
      action="completions"
      shift
      shisper_completions_parse_requirements "$@"
      shift $#
      ;;

    # :command.command_fallback
    "")
      shisper_usage >&2
      exit 1
      ;;

    *)
      printf "invalid command: %s\n" "$action" >&2
      exit 1
      ;;

  esac

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
shisper_play_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        shisper_play_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="play"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        if [[ -z ${args['media_file']+x} ]]; then

          args['media_file']=$1
          shift
        elif [[ -z ${args['sub_format']+x} ]]; then

          args['sub_format']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['media_file']+x} ]]; then
    printf "missing required argument: MEDIA_FILE\nusage: shisper play MEDIA_FILE [SUB_FORMAT]\n" >&2
    exit 1
  fi

  # :command.default_assignments
  [[ -n ${args['sub_format']:-} ]] || args['sub_format']="srt"

}

# :command.parse_requirements
shisper_stream_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        shisper_stream_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="stream"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
shisper_transcribe_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        shisper_transcribe_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="transcribe"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        if [[ -z ${args['media_file']+x} ]]; then

          args['media_file']=$1
          shift
        elif [[ -z ${args['sub_format']+x} ]]; then

          args['sub_format']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['media_file']+x} ]]; then
    printf "missing required argument: MEDIA_FILE\nusage: shisper transcribe MEDIA_FILE [SUB_FORMAT]\n" >&2
    exit 1
  fi

  # :command.default_assignments
  [[ -n ${args['sub_format']:-} ]] || args['sub_format']="srt"

}

# :command.parse_requirements
shisper_list_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        shisper_list_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="list"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
shisper_completions_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        shisper_completions_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="completions"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.initialize
initialize() {
  version="0.2.1"
  long_usage=''
  set -e

  # :command.environment_variables_default
  export MODEL_PATH="${MODEL_PATH:-${HOME}/.local/share/whispercpp}"

  # src/initialize.sh
  #!/usr/bin/env bash

  required_executables=(whisper.cpp ffmpeg mpv)

  check_requirements() {
    for executable in "${required_executables[@]}"; do
      if ! command -v "${executable}" &>/dev/null; then
        echo -e "[$(red_bold " FAILED ")] ${executable} executable is required"
        exit 1
      fi

    done
  }

  check_requirements

}

# :command.run
run() {
  declare -A args=()
  declare -A deps=()
  declare -a other_args=()
  declare -a input=()
  normalize_input "$@"
  parse_requirements "${input[@]}"

  case "$action" in
    "play") shisper_play_command ;;
    "stream") shisper_stream_command ;;
    "transcribe") shisper_transcribe_command ;;
    "list") shisper_list_command ;;
    "completions") shisper_completions_command ;;
  esac
}

initialize
run "$@"

#!/usr/bin/env bash
# This script was generated by bashly 1.0.1 (https://bashly.dannyb.co)
# Modifying it manually is not recommended

# :wrapper.bash3_bouncer
if [[ "${BASH_VERSINFO:-0}" -lt 4 ]]; then
  printf "bash version 4 or higher is required\n" >&2
  exit 1
fi

# :command.master_script

# :command.version_command
version_command() {
  echo "$version"
}

# :command.usage
shisper_usage() {
  if [[ -n $long_usage ]]; then
    printf "shisper - A quick & dirty script to generate subs for your multimedia files.\n"
    echo

  else
    printf "shisper - A quick & dirty script to generate subs for your multimedia files.\n"
    echo

  fi

  printf "%s\n" "Usage:"
  printf "  shisper COMMAND\n"
  printf "  shisper [COMMAND] --help | -h\n"
  printf "  shisper --version | -v\n"
  echo
  # :command.usage_commands
  printf "%s\n" "Commands:"
  printf "  %s   Generate bash completions\n" "completions"
  printf "  %s   Generate subtitles for any kind of media file\n" "transcribe "
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo
    printf "  %s\n" "--version, -v"
    printf "    Show version number\n"
    echo

    # :command.usage_environment_variables
    printf "%s\n" "Environment Variables:"

    # :environment_variable.usage
    printf "  %s\n" "STORAGE (required)"
    printf "    Set your storage home path\n"
    printf "    Default: ${HOME}/.shisperrc\n"
    echo

    # :environment_variable.usage
    printf "  %s\n" "MODEL_PATH (required)"
    printf "    Set the model home path\n"
    printf "    Default: ${HOME}/.local/share/whispercpp\n"
    echo

  fi
}

# :command.usage
shisper_completions_usage() {
  if [[ -n $long_usage ]]; then
    printf "shisper completions\n"
    echo

    printf "  Generate bash completions\n  Usage: eval \"\$(shisper completions)\"\n"
    echo

  else
    printf "shisper completions - Generate bash completions\n"
    echo

  fi

  printf "%s\n" "Usage:"
  printf "  shisper completions\n"
  printf "  shisper completions --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
shisper_transcribe_usage() {
  if [[ -n $long_usage ]]; then
    printf "shisper transcribe - Generate subtitles for any kind of media file\n"
    echo

  else
    printf "shisper transcribe - Generate subtitles for any kind of media file\n"
    echo

  fi

  printf "%s\n" "Usage:"
  printf "  shisper transcribe MEDIA_FILE\n"
  printf "  shisper transcribe --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "MEDIA_FILE"
    printf "    Video or audio file\n"
    echo

    # :command.usage_examples
    printf "%s\n" "Examples:"
    printf "  shisper transcribe my_video.mkv\n"
    printf "  shisper transcribe my_audio.mp3\n"
    echo

  fi
}

# :command.normalize_input
normalize_input() {
  local arg flags

  while [[ $# -gt 0 ]]; do
    arg="$1"
    if [[ $arg =~ ^(--[a-zA-Z0-9_\-]+)=(.+)$ ]]; then
      input+=("${BASH_REMATCH[1]}")
      input+=("${BASH_REMATCH[2]}")
    elif [[ $arg =~ ^(-[a-zA-Z0-9])=(.+)$ ]]; then
      input+=("${BASH_REMATCH[1]}")
      input+=("${BASH_REMATCH[2]}")
    elif [[ $arg =~ ^-([a-zA-Z0-9][a-zA-Z0-9]+)$ ]]; then
      flags="${BASH_REMATCH[1]}"
      for ((i = 0; i < ${#flags}; i++)); do
        input+=("-${flags:i:1}")
      done
    else
      input+=("$arg")
    fi

    shift
  done
}
# :command.inspect_args
inspect_args() {
  if ((${#args[@]})); then
    readarray -t sorted_keys < <(printf '%s\n' "${!args[@]}" | sort)
    echo args:
    for k in "${sorted_keys[@]}"; do echo "- \${args[$k]} = ${args[$k]}"; done
  else
    echo args: none
  fi

  if ((${#other_args[@]})); then
    echo
    echo other_args:
    echo "- \${other_args[*]} = ${other_args[*]}"
    for i in "${!other_args[@]}"; do
      echo "- \${other_args[$i]} = ${other_args[$i]}"
    done
  fi

  if ((${#deps[@]})); then
    readarray -t sorted_keys < <(printf '%s\n' "${!deps[@]}" | sort)
    echo
    echo deps:
    for k in "${sorted_keys[@]}"; do echo "- \${deps[$k]} = ${deps[$k]}"; done
  fi

}

# :command.user_lib
# src/lib/colors.sh
print_in_color() {
  local color="$1"
  shift
  if [[ -z ${NO_COLOR+x} ]]; then
    printf "$color%b\e[0m\n" "$*"
  else
    printf "%b\n" "$*"
  fi
}

red() { print_in_color "\e[31m" "$*"; }
green() { print_in_color "\e[32m" "$*"; }
yellow() { print_in_color "\e[33m" "$*"; }
blue() { print_in_color "\e[34m" "$*"; }
magenta() { print_in_color "\e[35m" "$*"; }
cyan() { print_in_color "\e[36m" "$*"; }
bold() { print_in_color "\e[1m" "$*"; }
underlined() { print_in_color "\e[4m" "$*"; }
red_bold() { print_in_color "\e[1;31m" "$*"; }
green_bold() { print_in_color "\e[1;32m" "$*"; }
yellow_bold() { print_in_color "\e[1;33m" "$*"; }
blue_bold() { print_in_color "\e[1;34m" "$*"; }
magenta_bold() { print_in_color "\e[1;35m" "$*"; }
cyan_bold() { print_in_color "\e[1;36m" "$*"; }
red_underlined() { print_in_color "\e[4;31m" "$*"; }
green_underlined() { print_in_color "\e[4;32m" "$*"; }
yellow_underlined() { print_in_color "\e[4;33m" "$*"; }
blue_underlined() { print_in_color "\e[4;34m" "$*"; }
magenta_underlined() { print_in_color "\e[4;35m" "$*"; }
cyan_underlined() { print_in_color "\e[4;36m" "$*"; }

# src/lib/media.sh
#!/usr/bin/env bash

check_media_type() {
  local media_file="$1"

  mime_type=$(file -i "${media_file}" | cut -d":" -f 2)
  mime_type_stripped="${mime_type//[[:blank:]]/}"
  media_type="${mime_type_stripped//;*/}"

  case "${media_type}" in
  audio*)
    ;;
  video*)
    ;;
  stream*)
    ;;
  *)
    echo -e "[$(red_bold "FAILED")] File type not supported : ${media_type}"
    exit 1
    ;;
  esac

  echo -e "[$(green_bold "  OK  ")] File media type detected: ${media_type}"

}

extract_audio() {
  local media_file="$1"

  echo -e "[$(cyan_bold " INFO ")] Extracting main track as 16Khz wav from ..."
  echo -e "[$(cyan_bold " INFO ")] ${media_file}"

  ffmpeg -y \
    -i "${media_file}" \
    -acodec pcm_s16le -ac 1 -ar 16000 \
    "${media_file}.wav" 2>/dev/null

  echo -e "[$(green_bold "  OK  ")] Audio extraction completed. File is:"
  echo -e "[$(cyan_bold " INFO ")] ${media_file}.wav"

}

# src/lib/utils.sh
#!/usr/bin/env bash

clean_temp_file() {
  local media_file="$1"

  echo -e "[$(cyan_bold " INFO ")] Deleting temporary wav files"
  rm "${media_file}.wav"
}

# src/lib/whisper.sh
#!/usr/bin/env bash

run_whisper() {
  local media_file="$1"

  whisper.cpp \
    -m /home/gianluca/.local/share/whispercpp/ggml-base.en.bin \
    -f "${media_file}.wav" \
    --output-srt \
    --print-progress > /dev/null
}

# :command.command_functions
# :command.function
shisper_completions_command() {
  # src/completions_command.sh
  echo "# this file is located in 'src/completions_command.sh'"
  echo "# code for 'shisper completions' goes here"
  echo "# you can edit it freely and regenerate (it will not be overwritten)"
  inspect_args

}

# :command.function
shisper_transcribe_command() {
  # src/transcribe_command.sh
  #!/usr/bin/env bash

  media_file="${args[media_file]}"

  check_media_type "${media_file}"
  extract_audio "${media_file}"
  run_whisper "${media_file}"
  clean_temp_file "${media_file}"
}

# :command.parse_requirements
parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --version | -v)
        version_command
        exit
        ;;

      --help | -h)
        long_usage=yes
        shisper_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.environment_variables_filter
  # :command.environment_variables_default
  export STORAGE="${STORAGE:-${HOME}/.shisperrc}"
  export MODEL_PATH="${MODEL_PATH:-${HOME}/.local/share/whispercpp}"

  if [[ -z "${STORAGE:-}" ]]; then
    printf "missing required environment variable: STORAGE\n" >&2
    exit 1
  fi
  if [[ -z "${MODEL_PATH:-}" ]]; then
    printf "missing required environment variable: MODEL_PATH\n" >&2
    exit 1
  fi

  # :command.dependencies_filter

  # :command.command_filter
  action=${1:-}

  case $action in
    -*) ;;

    completions)
      action="completions"
      shift
      shisper_completions_parse_requirements "$@"
      shift $#
      ;;

    transcribe)
      action="transcribe"
      shift
      shisper_transcribe_parse_requirements "$@"
      shift $#
      ;;

    # :command.command_fallback
    "")
      shisper_usage >&2
      exit 1
      ;;

    *)
      printf "invalid command: %s\n" "$action" >&2
      exit 1
      ;;

  esac

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
shisper_completions_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        shisper_completions_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.dependencies_filter

  # :command.command_filter
  action="completions"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
shisper_transcribe_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        shisper_transcribe_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.dependencies_filter

  # :command.command_filter
  action="transcribe"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        if [[ -z ${args['media_file']+x} ]]; then

          args['media_file']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['media_file']+x} ]]; then
    printf "missing required argument: MEDIA_FILE\nusage: shisper transcribe MEDIA_FILE\n" >&2
    exit 1
  fi

}

# :command.initialize
initialize() {
  version="0.1"
  long_usage=''
  set -e

  # :command.environment_variables_default
  export STORAGE="${STORAGE:-${HOME}/.shisperrc}"
  export MODEL_PATH="${MODEL_PATH:-${HOME}/.local/share/whispercpp}"

  # src/initialize.sh

}

# :command.run
run() {
  declare -A args=()
  declare -A deps=()
  declare -a other_args=()
  declare -a input=()
  normalize_input "$@"
  parse_requirements "${input[@]}"

  case "$action" in
    "completions")
      if [[ ${args['--help']:-} ]]; then
        long_usage=yes
        shisper_completions_usage
      else
        shisper_completions_command
      fi
      ;;

    "transcribe")
      if [[ ${args['--help']:-} ]]; then
        long_usage=yes
        shisper_transcribe_usage
      else
        shisper_transcribe_command
      fi
      ;;

  esac
}

initialize
run "$@"

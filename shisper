#!/usr/bin/env bash
# This script was generated by bashly 1.2.11 (https://bashly.dev)
# Modifying it manually is not recommended

# :wrapper.bash3_bouncer
if [[ "${BASH_VERSINFO:-0}" -lt 4 ]]; then
  printf "bash version 4 or higher is required\n" >&2
  exit 1
fi

# :command.master_script

# :command.version_command
version_command() {
  echo "$version"
}

# :command.usage
shisper_usage() {
  printf "shisper - A quick & dirty script to generate subs and transcriptions for your multimedia files.\n\n"

  printf "%s\n" "Usage:"
  printf "  shisper COMMAND\n"
  printf "  shisper [COMMAND] --help | -h\n"
  printf "  shisper --version | -v\n"
  echo
  # :command.usage_commands
  printf "%s\n" "Commands:"
  printf "  %s   Play a media file with generated subtitles / transcriptions\n" "play       "
  printf "  %s   Generate subtitles / transcriptions for any kind of media file\n" "transcribe "
  printf "  %s   Show the entire config file\n" "list       "
  printf "  %s   Generate bash completions\n" "completions"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo
    printf "  %s\n" "--version, -v"
    printf "    Show version number\n"
    echo

    # :command.usage_environment_variables
    printf "%s\n" "Environment Variables:"

    # :environment_variable.usage
    printf "  %s\n" "MODEL_PATH"
    printf "    Set the model home path\n"
    printf "    %s\n" "Default: ${HOME}/.local/share/whispercpp"
    echo

  fi
}

# :command.usage
shisper_play_usage() {
  printf "shisper play - Play a media file with generated subtitles / transcriptions\n\n"

  printf "%s\n" "Usage:"
  printf "  shisper play MEDIA_FILE [OPTIONS]\n"
  printf "  shisper play --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--format, -f FORMAT"
    printf "    Format for subtitles / transcription\n    \n    Supported values:\n    txt vtt srt lrc words csv json json-full\n"
    printf "    %s\n" "Default: srt"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "MEDIA_FILE"
    printf "    Video or audio file\n"
    echo

  fi
}

# :command.usage
shisper_transcribe_usage() {
  printf "shisper transcribe - Generate subtitles / transcriptions for any kind of media file\n\n"

  printf "%s\n" "Usage:"
  printf "  shisper transcribe MEDIA_FILE [OPTIONS]\n"
  printf "  shisper transcribe --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--format, -f FORMAT"
    printf "    Format for subtitles / transcription\n    \n    Supported values:\n    txt vtt srt lrc words csv json\n"
    printf "    %s\n" "Default: srt"
    echo

    # :flag.usage
    printf "  %s\n" "--lang, -l LANG"
    printf "    Spoken language ('auto' for auto-detect)\n"
    printf "    %s\n" "Default: auto"
    echo

    # :flag.usage
    printf "  %s\n" "--model, -m MODEL"
    printf "    Whisper models converted in ggml format\n    \n    Supported values:\n      tiny tiny.en base base.en small small.en medium medium.en large-v1\n    large-v2 large\n      note: large corresponds to the latest Large v3 model\n"
    printf "    %s\n" "Default: tiny"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "MEDIA_FILE"
    printf "    Video or audio file\n"
    echo

    # :command.usage_examples
    printf "%s\n" "Examples:"
    printf "  shisper transcribe --model large my_video.mkv\n"
    printf "  shisper transcribe my_audio.mp3\n"
    echo

  fi
}

# :command.usage
shisper_list_usage() {
  printf "shisper list - Show the entire config file\n\n"
  printf "Alias: l\n"
  echo

  printf "%s\n" "Usage:"
  printf "  shisper list\n"
  printf "  shisper list --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
shisper_completions_usage() {
  if [[ -n $long_usage ]]; then
    printf "shisper completions\n\n"
    printf "  Generate bash completions\n  Usage: eval \"\$(shisper completions)\"\n\n"
  else
    printf "shisper completions - Generate bash completions\n\n"
  fi

  printf "%s\n" "Usage:"
  printf "  shisper completions\n"
  printf "  shisper completions --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_examples
    printf "%s\n" "Examples:"
    printf "  shisper play my_video.mkv\n"
    printf "  shisper play my_audio.mp3\n"
    echo

  fi
}

# :command.normalize_input
# :command.normalize_input_function
normalize_input() {
  local arg passthru flags
  passthru=false

  while [[ $# -gt 0 ]]; do
    arg="$1"
    if [[ $passthru == true ]]; then
      input+=("$arg")
    elif [[ $arg =~ ^(--[a-zA-Z0-9_\-]+)=(.+)$ ]]; then
      input+=("${BASH_REMATCH[1]}")
      input+=("${BASH_REMATCH[2]}")
    elif [[ $arg =~ ^(-[a-zA-Z0-9])=(.+)$ ]]; then
      input+=("${BASH_REMATCH[1]}")
      input+=("${BASH_REMATCH[2]}")
    elif [[ $arg =~ ^-([a-zA-Z0-9][a-zA-Z0-9]+)$ ]]; then
      flags="${BASH_REMATCH[1]}"
      for ((i = 0; i < ${#flags}; i++)); do
        input+=("-${flags:i:1}")
      done
    elif [[ "$arg" == "--" ]]; then
      passthru=true
      input+=("$arg")
    else
      input+=("$arg")
    fi

    shift
  done
}

# :command.inspect_args
inspect_args() {
  if ((${#args[@]})); then
    readarray -t sorted_keys < <(printf '%s\n' "${!args[@]}" | sort)
    echo args:
    for k in "${sorted_keys[@]}"; do
      echo "- \${args[$k]} = ${args[$k]}"
    done
  else
    echo args: none
  fi

  if ((${#deps[@]})); then
    readarray -t sorted_keys < <(printf '%s\n' "${!deps[@]}" | sort)
    echo
    echo deps:
    for k in "${sorted_keys[@]}"; do
      echo "- \${deps[$k]} = ${deps[$k]}"
    done
  fi

  if ((${#env_var_names[@]})); then
    readarray -t sorted_names < <(printf '%s\n' "${env_var_names[@]}" | sort)
    echo
    echo "environment variables:"
    for k in "${sorted_names[@]}"; do
      echo "- \$$k = ${!k:-}"
    done
  fi
}

# :command.user_lib
# src/lib/colors.sh
print_in_color() {
  local color="$1"
  shift
  if [[ -z ${NO_COLOR+x} ]]; then
    printf "$color%b\e[0m\n" "$*"
  else
    printf "%b\n" "$*"
  fi
}

red() { print_in_color "\e[31m" "$*"; }
green() { print_in_color "\e[32m" "$*"; }
yellow() { print_in_color "\e[33m" "$*"; }
blue() { print_in_color "\e[34m" "$*"; }
magenta() { print_in_color "\e[35m" "$*"; }
cyan() { print_in_color "\e[36m" "$*"; }
bold() { print_in_color "\e[1m" "$*"; }
underlined() { print_in_color "\e[4m" "$*"; }
red_bold() { print_in_color "\e[1;31m" "$*"; }
green_bold() { print_in_color "\e[1;32m" "$*"; }
yellow_bold() { print_in_color "\e[1;33m" "$*"; }
blue_bold() { print_in_color "\e[1;34m" "$*"; }
magenta_bold() { print_in_color "\e[1;35m" "$*"; }
cyan_bold() { print_in_color "\e[1;36m" "$*"; }
red_underlined() { print_in_color "\e[4;31m" "$*"; }
green_underlined() { print_in_color "\e[4;32m" "$*"; }
yellow_underlined() { print_in_color "\e[4;33m" "$*"; }
blue_underlined() { print_in_color "\e[4;34m" "$*"; }
magenta_underlined() { print_in_color "\e[4;35m" "$*"; }
cyan_underlined() { print_in_color "\e[4;36m" "$*"; }

# src/lib/media.sh
#!/usr/bin/env bash

check_media_type() {
  local media_file="$1"

  mime_type=$(file -i "${media_file}" | cut -d":" -f 2)
  mime_type_stripped="${mime_type//[[:blank:]]/}"
  media_type="${mime_type_stripped//;*/}"

  case "${media_type}" in
    audio*) ;;
    video*) ;;
    *)
      echo -e "[$(red_bold "FAILED")] File type not supported : ${media_type}"
      exit 1
      ;;
  esac

  echo -e "[$(green_bold "  OK  ")] File media type detected: ${media_type}"

}

extract_audio() {
  local media_file="$1"

  echo -e "[$(cyan_bold " INFO ")] Extracting main track as 16Khz wav from ..."
  echo -e "${media_file}"

  ffmpeg -y \
    -loglevel quiet \
    -i "${media_file}" \
    -acodec pcm_s16le -ac 1 -ar 16000 \
    -f wav \
    "${media_file%.*}"

  echo -e "[$(green_bold "  OK  ")] Audio extraction completed. File is:"
  echo -e "${media_file%.*}"

}

play_media() {
  local media_file="$1"
  local sub_format="$2"

  echo -e "[$(cyan_bold " INFO ")] Playing file with generated transcription ..."
  echo -e "${media_file}"

  mpv \
    --quiet \
    --sub-file="${media_file%.*}.${sub_format}" \
    "${media_file}" 1>/dev/null

  echo -e "[$(green_bold "  OK  ")] Playback completed."
}

# src/lib/utils.sh
#!/usr/bin/env bash

clean_temp_file() {
  local media_file="$1"

  echo -e "[$(cyan_bold " INFO ")] Deleting temporary wav files"
  rm "${media_file%.*}"
}

check_media() {
  local media_file="$1"

  if [[ ! -f "${media_file}" ]]; then
    echo -e "[$(red_bold " FAILED ")] File not found"
    exit 1
  fi
}

check_models() {
  local model_file="$1"

  if [[ ! -d "${MODEL_PATH}" ]]; then
    mkdir -p "${MODEL_PATH}"
  fi

  if [[ -f "${MODEL_PATH}/ggml-${model_file}.bin" ]]; then
    echo -e "[$(cyan_bold " INFO ")] ${MODEL_PATH}/ggml-${model_file}.bin is present"
  else
    download_model "${model_file}"
  fi
}

check_sub() {
  local media_file="$1"
  local sub_format="$2"

  if [[ ! -f "${media_file%.*}.${sub_format}" ]]; then
    echo -e "[$(red_bold " FAILED ")] Generated transcription not found"
    exit 1
  fi
}

# src/lib/whisper.sh
#!/usr/bin/env bash
download_model() {
  local model="$1"

  echo -e "[$(cyan_bold " INFO ")] Downloading latest ggml-${model}.bin ..."
  curl -# -L -C - "https://ggml.ggerganov.com/ggml-model-whisper-${model}.bin" \
    -o "${MODEL_PATH}/ggml-${model}.bin"
}

run_whisper() {
  local media_file="$1"
  local model_file="$2"
  local lang="${3:-auto}"
  local sub_format="$4"

  whisper-cli \
    --file "${media_file%.*}" \
    --language "${lang}" \
    --model "${MODEL_PATH}/ggml-${model_file}.bin" \
    --output-"${sub_format}" \
    --no-timestamps >/dev/null

  echo -e "[$(green_bold "  OK  ")] Completed"
  echo -e "[$(cyan_bold " INFO ")] Generated transcription is:"
  echo -e "${media_file%.*}.${sub_format}"
}

# :command.command_functions
# :command.function
shisper_play_command() {

  # src/play_command.sh
  #!/usr/bin/env bash

  media_file="${args[media_file]}"
  sub_format="${args[sub_format]}"

  check_media "${media_file}"
  check_sub "${media_file}" "${sub_format}"
  play_media "${media_file}" "${sub_format}"
}

# :command.function
shisper_transcribe_command() {

  # src/transcribe_command.sh
  #!/usr/bin/env bash
  media_file="${args[media_file]}"
  lang="${args[--lang]}"
  model="${args[--model]}"
  sub_format="${args[--format]}"

  check_media "${media_file}"
  check_media_type "${media_file}"
  extract_audio "${media_file}"
  check_models "${model}"
  run_whisper "${media_file}" "${model}" "${lang}" "${sub_format}"
  clean_temp_file "${media_file}"

}

# :command.function
shisper_list_command() {

  # src/list_command.sh
  #!/usr/bin/env bash

  # Using the standard library (lib/config.sh) to show the entire config file
  config_show

  # Or to iterate through keys
  for key in $(config_keys); do
    echo "$key === $(config_get "${key}")"
  done

}

# :command.function
shisper_completions_command() {

  # src/completions_command.sh
  echo "# this file is located in 'src/completions_command.sh'"
  echo "# code for 'shisper completions' goes here"
  echo "# you can edit it freely and regenerate (it will not be overwritten)"
  inspect_args

}

# :command.parse_requirements
parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --version | -v)
        version_command
        exit
        ;;

      --help | -h)
        long_usage=yes
        shisper_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.environment_variables_filter
  # :command.environment_variables_default
  export MODEL_PATH="${MODEL_PATH:-${HOME}/.local/share/whispercpp}"

  env_var_names+=("MODEL_PATH")

  # :command.command_filter
  action=${1:-}

  case $action in
    -*) ;;

    play)
      action="play"
      shift
      shisper_play_parse_requirements "$@"
      shift $#
      ;;

    transcribe)
      action="transcribe"
      shift
      shisper_transcribe_parse_requirements "$@"
      shift $#
      ;;

    list | l)
      action="list"
      shift
      shisper_list_parse_requirements "$@"
      shift $#
      ;;

    completions)
      action="completions"
      shift
      shisper_completions_parse_requirements "$@"
      shift $#
      ;;

    # :command.command_fallback
    "")
      shisper_usage >&2
      exit 1
      ;;

    *)
      printf "invalid command: %s\n" "$action" >&2
      exit 1
      ;;

  esac

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
shisper_play_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        shisper_play_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="play"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --format | -f)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--format']="$2"
          shift
          shift
        else
          printf "%s\n" "--format requires an argument: --format, -f FORMAT" >&2
          exit 1
        fi
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['media_file']+x} ]]; then
          args['media_file']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['media_file']+x} ]]; then
    printf "missing required argument: MEDIA_FILE\nusage: shisper play MEDIA_FILE [OPTIONS]\n" >&2

    exit 1
  fi

  # :command.default_assignments
  [[ -n ${args['--format']:-} ]] || args['--format']="srt"

}

# :command.parse_requirements
shisper_transcribe_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        shisper_transcribe_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="transcribe"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --format | -f)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--format']="$2"
          shift
          shift
        else
          printf "%s\n" "--format requires an argument: --format, -f FORMAT" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --lang | -l)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--lang']="$2"
          shift
          shift
        else
          printf "%s\n" "--lang requires an argument: --lang, -l LANG" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --model | -m)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--model']="$2"
          shift
          shift
        else
          printf "%s\n" "--model requires an argument: --model, -m MODEL" >&2
          exit 1
        fi
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['media_file']+x} ]]; then
          args['media_file']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['media_file']+x} ]]; then
    printf "missing required argument: MEDIA_FILE\nusage: shisper transcribe MEDIA_FILE [OPTIONS]\n" >&2

    exit 1
  fi

  # :command.default_assignments
  [[ -n ${args['--format']:-} ]] || args['--format']="srt"
  [[ -n ${args['--lang']:-} ]] || args['--lang']="auto"
  [[ -n ${args['--model']:-} ]] || args['--model']="tiny"

}

# :command.parse_requirements
shisper_list_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        shisper_list_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="list"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
shisper_completions_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        shisper_completions_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="completions"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.initialize
initialize() {
  declare -g version="0.2.5"
  set -e

  # :command.environment_variables_default
  export MODEL_PATH="${MODEL_PATH:-${HOME}/.local/share/whispercpp}"

  # src/initialize.sh
  #!/usr/bin/env bash

  required_executables=(whisper-cli ffmpeg mpv)

  check_requirements() {
    for executable in "${required_executables[@]}"; do
      if ! command -v "${executable}" &>/dev/null; then
        echo -e "[$(red_bold " FAILED ")] ${executable} executable is required"
        exit 1
      fi

    done
  }

  check_requirements

}

# :command.run
run() {
  # :command.globals
  declare -g long_usage=''
  declare -g -A args=()
  declare -g -A deps=()
  declare -g -a env_var_names=()
  declare -g -a input=()

  normalize_input "$@"
  parse_requirements "${input[@]}"

  case "$action" in
    "play") shisper_play_command ;;
    "transcribe") shisper_transcribe_command ;;
    "list") shisper_list_command ;;
    "completions") shisper_completions_command ;;
  esac
}

if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
  initialize
  run "$@"
fi
